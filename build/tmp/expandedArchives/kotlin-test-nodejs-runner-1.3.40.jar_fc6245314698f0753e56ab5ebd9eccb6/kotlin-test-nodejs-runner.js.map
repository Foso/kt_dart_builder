{"version":3,"file":"kotlin-test-nodejs-runner.js","sources":["../src/utils.ts","../src/TeamCityMessagesFlow.ts","../src/KotlinTestTeamCityReporter.ts","../src/CliArgsParser.ts","../src/KotlinTestsFilter.ts","../src/Timer.ts","../cli.ts","../src/KotlinTestRunner.ts","../src/CliFiltertingConfiguration.ts"],"sourcesContent":["\n/**\n * from teamcity-service-messages\n * Copyright (c) 2013 Aaron Forsander\n *\n * Escape string for TeamCity output.\n * @see https://confluence.jetbrains.com/display/TCD65/Build+Script+Interaction+with+TeamCity#BuildScriptInteractionwithTeamCity-servMsgsServiceMessages\n */\nexport function tcEscape(str: string): string {\n    if (!str) {\n        return '';\n    }\n\n    return str\n        .toString()\n        .replace(/\\|/g, '||')\n        .replace(/\\n/g, '|n')\n        .replace(/\\r/g, '|r')\n        .replace(/\\[/g, '|[')\n        .replace(/\\]/g, '|]')\n        .replace(/\\u0085/g, '|x') // next line\n        .replace(/\\u2028/g, '|l') // line separator\n        .replace(/\\u2029/g, '|p') // paragraph separator\n        .replace(/'/g, '|\\'');\n}\n\n/**\n * From teamcity-service-messages.\n * Copyright 2013 Aaron Forsander\n */\nexport function newFlowId(): number {\n    return Math.floor(Math.random() * (1e10 - 1e6 + 1)) + 1e6;\n}\n\n/**\n * From teamcity-service-messages.\n * Copyright 2013 Aaron Forsander\n */\nexport function dateTimeWithoutTimeZone(): string {\n    // TeamCity not fully support ISO 8601 (see TW-36173) so we need to cut off 'Z' at the end.\n    return new Date().toISOString().slice(0, -1);\n}\n\n/**\n * From lodash.\n * Copyright JS Foundation and other contributors <https://js.foundation/>\n */\nexport function startsWith(string: string, target: string) {\n    return string.slice(0, target.length) == target;\n}\n\n/**\n * From lodash.\n * Copyright JS Foundation and other contributors <https://js.foundation/>\n */\nexport function trim(str: string): string {\n    return str.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\n}\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nconst reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g,\n    reHasRegExpChar = RegExp(reRegExpChar.source);\n\n/**\n * Escapes the `RegExp` special characters \"^\", \"$\", \"\\\", \".\", \"*\", \"+\",\n * \"?\", \"(\", \")\", \"[\", \"]\", \"{\", \"}\", and \"|\" in `string`.\n *\n * From lodash.\n * Copyright JS Foundation and other contributors <https://js.foundation/>\n */\nexport function escapeRegExp(string: string) {\n    return (string && reHasRegExpChar.test(string))\n        ? string.replace(reRegExpChar, '\\\\$&')\n        : string;\n}\n\nexport function pushIfNotNull<T>(list: T[], value: T) {\n    if (value !== null) list.push(value)\n}\n\nexport function flatMap<T>(arr: T[], f: (item: T) => T[]): T[] {\n    const result: T[] = [];\n    arr.forEach(item => {\n        f(item).forEach(x => {\n            result.push(x)\n        })\n    });\n    return result;\n}\n\nexport function println(message ?: string) {\n    console.log(message)\n}","import {dateTimeWithoutTimeZone, newFlowId, tcEscape} from \"./utils\"\n\nexport type TeamCityMessageData = { [key: string]: any }\n\nexport class TeamCityMessagesFlow {\n    public readonly id: number;\n\n    constructor(id: number | null, private readonly send: (payload: string) => void) {\n        this.id = id || newFlowId()\n    }\n\n    sendMessage(type: string, args: TeamCityMessageData) {\n        args['flowId'] = this.id;\n        args['timestamp'] = dateTimeWithoutTimeZone();\n\n        const serializedArgs = Object\n            .keys(args)\n            .map((key) => `${key}='${tcEscape(args[key])}'`)\n            .join(' ');\n\n        this.send(`##teamcity[${type} ${serializedArgs}]`)\n    }\n}","import {KotlinTestRunner} from \"./KotlinTestRunner\";\nimport {TeamCityMessageData, TeamCityMessagesFlow} from \"./TeamCityMessagesFlow\";\nimport {Timer} from \"./Timer\";\n\nconst kotlin_test = require('kotlin-test');\n\n// don't use enum as it is not minified by uglify\nexport type IgnoredTestSuitesReporting\n    = \"skip\" | \"reportAsIgnoredTest\" | \"reportAllInnerTestsAsIgnored\"\nexport const IgnoredTestSuitesReporting: { [key: string]: IgnoredTestSuitesReporting } = {\n    skip: \"skip\",\n    reportAsIgnoredTest: \"reportAsIgnoredTest\",\n    reportAllInnerTestsAsIgnored: \"reportAllInnerTestsAsIgnored\"\n};\n\n// to reduce minified code size\nfunction withName(name: string, data?: TeamCityMessageData): TeamCityMessageData {\n    data = data || {};\n    data[\"name\"] = name;\n    return data\n}\n\nexport function runWithTeamCityReporter(\n    runner: KotlinTestRunner,\n    ignoredTestSuites: IgnoredTestSuitesReporting,\n    teamCity: TeamCityMessagesFlow,\n    timer: Timer<any> | null\n): KotlinTestRunner {\n    let inIgnoredSuite = false;\n    let currentAssertionResult: { expected: any, actual: any } | null = null;\n\n    kotlin_test.kotlin.test.setAssertHook_4duqou$(function (assertionResult: { expected: any, actual: any }) {\n        currentAssertionResult = assertionResult;\n    });\n\n    return {\n        suite: function (name: string, isIgnored: boolean, fn: () => void) {\n            if (isIgnored) {\n                if (ignoredTestSuites == IgnoredTestSuitesReporting.skip) return;\n                else if (ignoredTestSuites == IgnoredTestSuitesReporting.reportAsIgnoredTest) {\n                    teamCity.sendMessage('testIgnored', withName(name, {\"suite\": true}));\n                    return\n                }\n            }\n\n            teamCity.sendMessage('testSuiteStarted', withName(name));\n\n            // noinspection UnnecessaryLocalVariableJS\n            const alreadyInIgnoredSuite = inIgnoredSuite;\n            if (!alreadyInIgnoredSuite && isIgnored) {\n                inIgnoredSuite = true;\n            }\n\n            try {\n                if (isIgnored && ignoredTestSuites == IgnoredTestSuitesReporting.reportAllInnerTestsAsIgnored) {\n                    fn();\n                } else {\n                    runner.suite(name, isIgnored, fn)\n                }\n            } finally {\n                if (isIgnored && !alreadyInIgnoredSuite) {\n                    inIgnoredSuite = false;\n                }\n\n                const data: TeamCityMessageData = withName(name);\n\n                // extension only for Gradle\n                if (isIgnored) data[\"ignored\"] = true;\n\n                teamCity.sendMessage('testSuiteFinished', data);\n            }\n        },\n        test: function (name: string, isIgnored: boolean, fn: () => void) {\n            if (inIgnoredSuite || isIgnored) {\n                teamCity.sendMessage('testIgnored', withName(name));\n            } else {\n                const startTime = timer ? timer.start() : null;\n                teamCity.sendMessage('testStarted', withName(name));\n                try {\n                    runner.test(name, isIgnored, fn);\n                } catch (e) {\n                    const data: TeamCityMessageData = withName(name, {\n                        \"message\": e.message,\n                        \"details\": e.stack\n                    });\n\n                    if (currentAssertionResult) {\n                        data[\"type\"] = 'comparisonFailure';\n                        data[\"expected\"] = currentAssertionResult.expected;\n                        data[\"actual\"] = currentAssertionResult.actual;\n                    }\n                    teamCity.sendMessage('testFailed', data);\n                } finally {\n                    currentAssertionResult = null;\n                    const data: TeamCityMessageData = withName(name);\n                    if (startTime) {\n                        data[\"duration\"] = timer!!.end(startTime); // ns to ms\n                    }\n                    teamCity.sendMessage('testFinished', data);\n                }\n            }\n        }\n    }\n}","import {println, startsWith} from \"./utils\";\n\nexport type CliDescription = {\n    version: string,\n    bin: string,\n    description: string,\n    usage: string,\n    args: {\n        [k: string]: CliArgDescription,\n    },\n    freeArgsTitle: string\n}\n\nexport type CliArgValues = {\n    [k: string]: string[] | string,\n    free: string[]\n}\n\nexport type CliArgDescription = {\n    keys: string[],\n    help: string,\n    values?: string[],\n    valuesHelp?: string[],\n    default?: string,\n    single?: true\n}\n\nexport class CliArgsParser {\n    constructor(private description: CliDescription) {\n    }\n\n    printUsage() {\n        const description = this.description;\n\n        println(`${description.bin} v${description.version} - ${description.description}`);\n        println();\n        println(`Usage: ${description.bin} ${description.usage}`);\n        println();\n        for (let key in description.args) {\n            const data = description.args[key];\n            println('  ' + data.keys.join(', '));\n            const indent = '    ';\n            println(`${indent}${data.help}`);\n            if (data.values && data.valuesHelp) {\n                println(`${indent}Possible values:`);\n                for (let i = 0; i < data.values.length; i++) {\n                    const value = data.values[i];\n                    const help = data.valuesHelp[i];\n                    println(`${indent} - \"${value}\": ${help}`)\n                }\n            }\n            if (data.default) println(`${indent}By default: ${data.default}`);\n            println('')\n        }\n    }\n\n    badArgsExit(message: string) {\n        println(message);\n        println();\n        this.printUsage();\n        process.exit(1)\n    }\n\n    parse(args: string[]): CliArgValues {\n        const description = this.description;\n\n        const result: CliArgValues = {\n            free: []\n        };\n        for (let key in description.args) {\n            if (!description.args[key].single) {\n                result[key] = [];\n            }\n        }\n\n        // process all arguments from left to right\n        args: while (args.length != 0) {\n            const arg = args.shift() as string;\n\n            if (startsWith(arg, '--')) {\n                for (let argName in description.args) {\n                    const argDescription = description.args[argName];\n                    if (argDescription.keys.indexOf(arg) != -1) {\n                        if (args.length == 0) {\n                            this.badArgsExit(\"Missed value after option \" + arg);\n                        }\n\n                        const value = args.shift() as string;\n                        if (argDescription.values && argDescription.values.indexOf(value) == -1) {\n                            this.badArgsExit(\"Unsupported value for option \" + arg);\n                        }\n\n                        if (argDescription.single) {\n                            result[argName] = value;\n                        } else {\n                            (result[argName] as string[]).push(value);\n                        }\n\n                        continue args;\n                    }\n                }\n\n                this.badArgsExit(\"Unknown option: \" + arg);\n            } else {\n                result.free.push(arg)\n            }\n        }\n\n        if (result.free.length == 0) {\n            this.badArgsExit(`At least one ${description.freeArgsTitle} should be provided`)\n        }\n\n        return result\n    }\n}\n","import {escapeRegExp, startsWith, trim} from \"./utils\";\nimport {KotlinTestRunner} from \"./KotlinTestRunner\";\n\nexport interface KotlinTestsFilter {\n    mayContainTestsFromSuite(fqn: string): boolean;\n\n    containsTest(fqn: string): boolean;\n}\n\nexport function runWithFilter(\n    runner: KotlinTestRunner,\n    filter: KotlinTestsFilter,\n): KotlinTestRunner {\n    let path: string[] = [];\n\n    function pathString() {\n        // skip root\n        return path.slice(1).join('.')\n    }\n\n    return {\n        suite: function (name: string, isIgnored: boolean, fn: () => void) {\n            path.push(name);\n\n            try {\n                if (path.length > 1 && !filter.mayContainTestsFromSuite(pathString())) return;\n\n                runner.suite(name, isIgnored, fn);\n            } finally {\n                path.pop()\n            }\n        },\n\n        test: function (name: string, isIgnored: boolean, fn: () => void) {\n            path.push(name);\n\n            try {\n                if (!filter.containsTest(pathString())) return;\n\n                runner.test(name, isIgnored, fn);\n            } finally {\n                path.pop()\n            }\n        }\n    };\n}\n\nexport function newKotlinTestsFilter(wildcard: string | null): KotlinTestsFilter | null {\n    if (wildcard == null) return null;\n    wildcard = trim(wildcard);\n    wildcard = wildcard.replace(/\\*+/, '*'); // ** => *\n    if (wildcard.length == 0) return null;\n    else if (wildcard == '*') return allTest;\n    else if (wildcard.indexOf('*') == -1) return new ExactFilter(wildcard);\n    else if (startsWith(wildcard, '*')) return new RegExpKotlinTestsFilter(wildcard);\n    else {\n        // optimize for cases like \"Something*\", \"Something*a*b\" and so on.\n        // by adding explicit prefix matcher to not visit unneeded suites\n        // (RegExpKotlinTestsFilter doesn't support suites matching)\n        const [prefix, rest] = wildcard.split('*', 2);\n        return new StartsWithFilter(prefix, rest ? new RegExpKotlinTestsFilter(wildcard) : null)\n    }\n}\n\nexport const allTest = new class implements KotlinTestsFilter {\n    mayContainTestsFromSuite(fqn: string): boolean {\n        return true;\n    }\n\n    containsTest(fqn: string): boolean {\n        return true;\n    }\n};\n\nexport class StartsWithFilter implements KotlinTestsFilter {\n    constructor(\n        public readonly prefix: string,\n        public readonly filter: RegExpKotlinTestsFilter | null\n    ) {\n    }\n\n    isPrefixMatched(fqn: string): boolean {\n        return startsWith(fqn + \".\", this.prefix);\n    }\n\n    mayContainTestsFromSuite(fqn: string): boolean {\n        return this.isPrefixMatched(fqn);\n    }\n\n    containsAllTestsFromSuite(fqn: string): boolean {\n        return this.filter == null && this.isPrefixMatched(fqn);\n    }\n\n    containsTest(fqn: string): boolean {\n        return startsWith(fqn, this.prefix)\n            && (this.filter == null || this.filter.containsTest(fqn));\n    }\n}\n\nexport class ExactFilter implements KotlinTestsFilter {\n    constructor(public fqn: string) {\n    }\n\n    mayContainTestsFromSuite(fqn: string): boolean {\n        return startsWith(fqn, this.fqn);\n    }\n\n    containsTest(fqn: string): boolean {\n        return fqn === this.fqn;\n    }\n}\n\nexport class RegExpKotlinTestsFilter implements KotlinTestsFilter {\n    public readonly regexp: RegExp;\n\n    constructor(wildcard: string) {\n        this.regexp = RegExp(wildcard\n            .split('*')\n            .map(it => escapeRegExp(it))\n            .join('.*'));\n    }\n\n    mayContainTestsFromSuite(fqn: string): boolean {\n        return true\n    }\n\n    containsTest(fqn: string): boolean {\n        return this.regexp!.test(fqn)\n    }\n\n    toString(): string {\n        return this.regexp.toString()\n    }\n}\n\nexport class CompositeTestFilter implements KotlinTestsFilter {\n    private readonly excludePrefix: StartsWithFilter[] = [];\n\n    constructor(\n        public include: KotlinTestsFilter[],\n        public exclude: KotlinTestsFilter[]\n    ) {\n        this.exclude.forEach(it => {\n            if (it instanceof StartsWithFilter && it.filter == null)\n                this.excludePrefix.push(it)\n        })\n    }\n\n    mayContainTestsFromSuite(fqn: string): boolean {\n        for (const excl of this.excludePrefix) {\n            if (excl.containsAllTestsFromSuite(fqn)) return false\n        }\n        for (const incl of this.include) {\n            if (incl.mayContainTestsFromSuite(fqn)) return true\n        }\n        return false;\n    }\n\n    containsTest(fqn: string): boolean {\n        for (const excl of this.exclude) {\n            if (excl.containsTest(fqn)) return false\n        }\n        for (const incl of this.include) {\n            if (incl.containsTest(fqn)) return true\n        }\n        return false\n    }\n}","export interface Timer<T> {\n    start(): T\n\n    end(start: T): number\n}\n\nexport const hrTimer: Timer<[number, number]> = {\n    start(): [number, number] {\n        return process.hrtime();\n    },\n    end(start: [number, number]): number {\n        const elapsedHr = process.hrtime(start);\n        return elapsedHr[0] + (elapsedHr[1] / 1e6); // ns to ms\n    }\n};\n\n","import {TeamCityMessagesFlow} from \"./src/TeamCityMessagesFlow\";\nimport {directRunner, KotlinTestRunner} from \"./src/KotlinTestRunner\";\nimport {IgnoredTestSuitesReporting, runWithTeamCityReporter} from \"./src/KotlinTestTeamCityReporter\";\nimport {CliArgsParser} from \"./src/CliArgsParser\";\nimport {configureFiltering} from \"./src/CliFiltertingConfiguration\";\nimport {hrTimer} from \"./src/Timer\";\n\nconst kotlin_test = require('kotlin-test');\n\nconst parser = new CliArgsParser({\n    version: VERSION,\n    bin: BIN,\n    description: DESCRIPTION,\n    usage: \"[-t --tests] [-e --exclude] <module_name1>, <module_name2>, ..\",\n    args: {\n        include: {\n            keys: ['--tests', '--include'],\n            help: \"Tests to include. Example: MySuite.test1,MySuite.MySubSuite.*,*unix*,!*windows*\",\n            default: \"*\"\n\n        },\n        exclude: {\n            keys: ['--exclude'],\n            help: \"Tests to exclude. Example: MySuite.test1,MySuite.MySubSuite.*,*unix*\"\n        },\n        ignoredTestSuites: {\n            keys: ['--ignoredTestSuites'],\n            help: \"How to deal with ignored test suites\",\n            single: true,\n            values: [\n                IgnoredTestSuitesReporting.skip,\n                IgnoredTestSuitesReporting.reportAsIgnoredTest,\n                IgnoredTestSuitesReporting.reportAllInnerTestsAsIgnored\n            ],\n            valuesHelp: [\n                \"don't report ignored test suites\",\n                \"useful to speedup large ignored test suites\",\n                \"will cause visiting all inner tests\",\n            ],\n            default: IgnoredTestSuitesReporting.reportAllInnerTestsAsIgnored\n        }\n    },\n    freeArgsTitle: \"module_name\"\n});\n\nconst processArgs = process.argv.slice(2);\nconst untypedArgs = parser.parse(processArgs);\nconst args = {\n    onIgnoredTestSuites: (untypedArgs.ignoredTestSuites\n        || IgnoredTestSuitesReporting.reportAllInnerTestsAsIgnored) as IgnoredTestSuitesReporting,\n    include: untypedArgs.include as string[],\n    exclude: untypedArgs.exclude as string[],\n};\n\nconst teamCity = new TeamCityMessagesFlow(null, (payload) => console.log(payload));\n\nlet runner: KotlinTestRunner = directRunner;\nrunner = runWithTeamCityReporter(runner, args.onIgnoredTestSuites, teamCity, hrTimer);\nrunner = configureFiltering(runner, args.include, args.exclude);\n\nkotlin_test.setAdapter(runner);\n\nuntypedArgs.free.forEach((arg: string) => {\n    require(arg);\n});","export interface KotlinTestRunner {\n    suite(name: string, isIgnored: boolean, fn: () => void): void\n\n    test(name: string, isIgnored: boolean, fn: () => void): void\n}\n\nexport const directRunner: KotlinTestRunner = {\n    suite(name: string, isIgnored: boolean, fn: () => void): void {\n        if (!isIgnored) fn()\n    },\n    test(name: string, isIgnored: boolean, fn: () => void): void {\n        if (!isIgnored) fn()\n    }\n};","import {KotlinTestRunner} from \"./KotlinTestRunner\";\nimport {\n    allTest,\n    CompositeTestFilter,\n    KotlinTestsFilter,\n    newKotlinTestsFilter,\n    runWithFilter\n} from \"./KotlinTestsFilter\";\nimport {flatMap, println, pushIfNotNull} from \"./utils\";\n\nexport function configureFiltering(\n    runner: KotlinTestRunner,\n    includeWildcards: string[],\n    excludeWildcards: string[]\n): KotlinTestRunner {\n    const include: KotlinTestsFilter[] = [];\n    const exclude: KotlinTestsFilter[] = [];\n\n    function collectWildcards(\n        value: string[],\n        positive: KotlinTestsFilter[],\n        negative: KotlinTestsFilter[]\n    ) {\n        flatMap(value, (t: string) => t.split(','))\n            .map(t => {\n                if (t.length && t[0] == '!') {\n                    pushIfNotNull(negative, newKotlinTestsFilter(t.substring(1)))\n                } else {\n                    pushIfNotNull(positive, newKotlinTestsFilter(t))\n                }\n            })\n    }\n\n    collectWildcards(includeWildcards, include, exclude);\n    collectWildcards(excludeWildcards, exclude, include);\n\n    if (include.length == 0 && exclude.length == 0) {\n        return runner\n    } else {\n        if (include.length == 0) {\n            include.push(allTest)\n        }\n\n        const filter = new CompositeTestFilter(include, exclude);\n\n        if (DEBUG) {\n            println(filter.toString());\n        }\n\n        return runWithFilter(runner, filter)\n    }\n}\n"],"names":["startsWith","string","target","slice","length","reRegExpChar","reHasRegExpChar","RegExp","source","pushIfNotNull","list","value","push","println","message","console","log","id","send","this","Math","floor","random","TeamCityMessagesFlow","type","args","Date","toISOString","serializedArgs","Object","keys","map","key","str","toString","replace","join","kotlin_test","require","IgnoredTestSuitesReporting","withName","name","data","description","CliArgsParser","bin","version","usage","indent","help","values","valuesHelp","i","default","printUsage","process","exit","result","d","single","arg","shift","argName","argDescription","indexOf","badArgsExit","free","freeArgsTitle","newKotlinTestsFilter","wildcard","allTest","ExactFilter","RegExpKotlinTestsFilter","_a","prefix","rest","StartsWithFilter","class_1","fqn","filter","isPrefixMatched","containsTest","regexp","split","it","test","include","exclude","forEach","_this","excludePrefix","CompositeTestFilter","_i","containsAllTestsFromSuite","_c","_b","mayContainTestsFromSuite","runner","ignoredTestSuites","teamCity","timer","inIgnoredSuite","currentAssertionResult","hrTimer","b","hrtime","I","start","elapsedHr","parser","s","VERSION","u","BIN","r","DESCRIPTION","o","f","T","l","a","k","q","g","c","p","processArgs","argv","untypedArgs","parse","U","payload","suite","isIgnored","fn","onIgnoredTestSuites","kotlin","setAssertHook_4duqou$","assertionResult","includeWildcards","excludeWildcards","collectWildcards","positive","negative","arr","t","item","x","substring","path","pathString","pop","runWithFilter","configureFiltering","sendMessage","alreadyInIgnoredSuite","startTime","e","details","stack","expected","actual","end","setAdapter"],"mappings":"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"}